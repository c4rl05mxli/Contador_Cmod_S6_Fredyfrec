KCPSM6 Assembler log file for program 'C:\FPGA\Contador_Cmod_S6_Fredyfrec\PSM\ROM.psm'.
Generated by KCPSM6 version v2.70
Ken Chapman - Xilinx Ltd - 16th May 2014

Assembly datestamp: 14 Oct 2018
Assembly timestamp: 14:30:33

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 272 hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 627
Memory locations available: 3469


Assembly listing

 Addr Code                          Instruction

 000                                ;
 000                                ; Constantes
 000                                ;
 000                                CONSTANT A_count0_port, 00          ; 32-bit A-counter (LSByte first)
 000                                CONSTANT A_count1_port, 01
 000                                CONSTANT A_count2_port, 02
 000                                CONSTANT A_count3_port, 03
 000                                ;
 000                                CONSTANT B_count0_port, 04          ; 32-bit B-counter (LSByte first)
 000                                CONSTANT B_count1_port, 05
 000                                CONSTANT B_count2_port, 06
 000                                CONSTANT B_count3_port, 07
 000                                ;
 000                                CONSTANT Timer1_F_0_port, 08        ; Timer 1 32 bit, de la parte fraccionaria
 000                                CONSTANT Timer1_F_1_port, 09
 000                                CONSTANT Timer1_F_2_port, 0A
 000                                CONSTANT Timer1_F_3_port, 0B
 000                                ;
 000                                CONSTANT Timer1_E_0_port, 0C        ; Timer 1 32 bit, de la parte Entera
 000                                CONSTANT Timer1_E_1_port, 0D
 000                                CONSTANT Timer1_E_2_port, 0E
 000                                CONSTANT Timer1_E_3_port, 0F
 000                                ;
 000                                CONSTANT Timer2_F_0_port, 18        ; Timer 2 32 bit, de la parte fraccionaria
 000                                CONSTANT Timer2_F_1_port, 19
 000                                CONSTANT Timer2_F_2_port, 1A
 000                                CONSTANT Timer2_F_3_port, 1B
 000                                ;
 000                                CONSTANT Timer2_E_0_port, 1C        ; Timer 2 32 bit, de la parte Entera
 000                                CONSTANT Timer2_E_1_port, 1D
 000                                CONSTANT Timer2_E_2_port, 1E
 000                                CONSTANT Timer2_E_3_port, 1F
 000                                ;
 000                                CONSTANT A_period0_port, 20         ; 32-bit A-period (LSByte first)
 000                                CONSTANT A_period1_port, 21
 000                                CONSTANT A_period2_port, 22
 000                                CONSTANT A_period3_port, 23
 000                                ;
 000                                CONSTANT B_period0_port, 24         ; 32-bit A-period (LSByte first)
 000                                CONSTANT B_period1_port, 25
 000                                CONSTANT B_period2_port, 26
 000                                CONSTANT B_period3_port, 27
 000                                ;
 000                                CONSTANT CTRL_status_port, 3F       ; Control status port
 000                                ;CONSTANT start_button, 01    ; bit start
 000                                ;Port definitions
 000                                ;
 000                                CONSTANT UART_status_port, 40       ; UART status input, lo cambie a la 40
 000                                CONSTANT tx_half_full, 01           ;  Transmitter     half full - bit0
 000                                CONSTANT tx_full, 02                ;    FIFO               full - bit1
 000                                CONSTANT rx_half_full, 04           ;  Receiver        half full - bit2
 000                                CONSTANT rx_full, 08                ;    FIFO               full - bit3
 000                                CONSTANT rx_data_present, 10        ;               data present - bit4
 000                                ;
 000                                CONSTANT UART_read_port, 80         ; UART Rx data input, lo cambie a 80, con el bit 7
 000                                ;
 000                                ;
 000                                ;
 000                                ; Definiciones de los puertos de Salida de Datos
 000                                CONSTANT UART_write_port, 80        ; port_id(0)='1'; UART Tx data output
 000                                CONSTANT Reset, 40                  ; port_id(1)='1'
 000                                CONSTANT START, 02
 000                                CONSTANT TG, 03                     ; latch config for TG
 000                                CONSTANT Dato0, 04                  ; port_id(2)='1'
 000                                CONSTANT Dato1, 05                  ; port_id(3)='1'
 000                                CONSTANT Dato2, 06                  ; port_id(4)='1'
 000                                CONSTANT Dato3, 07                  ; port_id(5)='1'
 000                                CONSTANT Time0, 08                  ; port_id(5)='1'
 000                                CONSTANT Time1, 09                  ; port_id(5)='1'
 000                                ;CONSTANT Start, 02
 000                                ;CONSTANT Stop,  01
 000                                ;CONSTANT PTL, 40      ; port_id(6)='1'
 000                                ;CONSTANT Dato3, 80      ; port_id(7)='1'
 000                                ;
 000                                ;
 000                                ;**************************************************************************************
 000                                ;Scratch Pad Memory Locations 64 Bytes (00 to 3F)
 000                                ;**************************************************************************************
 000                                CONSTANT count0, 00                 ;last 32-bit counter value (LSByte first)
 000                                CONSTANT count1, 01
 000                                CONSTANT count2, 02
 000                                CONSTANT count3, 03
 000                                ;
 000                                CONSTANT MODO, 04                   ; Aqui guardo el modo de operacion
 000                                CONSTANT COMANDO, 05                ; Aqui guardo el comando, en lectura 3
 000                                CONSTANT STATUS, 06                 ; Aqui guardo el Estado
 000                                ;BCD digits representing selected and displayed frequency
 000                                ;
 000                                CONSTANT BCD_digit0, 07             ; value           1
 000                                CONSTANT BCD_digit1, 08             ;                10
 000                                CONSTANT BCD_digit2, 09             ;               100
 000                                CONSTANT BCD_digit3, 0A             ;             1,000
 000                                CONSTANT BCD_digit4, 0B             ;            10,000
 000                                CONSTANT BCD_digit5, 0C             ;           100,000
 000                                CONSTANT BCD_digit6, 0D             ;         1,000,000
 000                                CONSTANT BCD_digit7, 0E             ;        10,000,000
 000                                CONSTANT BCD_digit8, 0F             ;       100,000,000
 000                                ;
 000                                CONSTANT decimal0, 10               ;10 digit decimal value up to 4,294,967,295
 000                                CONSTANT decimal1, 11
 000                                CONSTANT decimal2, 12
 000                                CONSTANT decimal3, 13
 000                                CONSTANT decimal4, 14
 000                                CONSTANT decimal5, 15
 000                                CONSTANT decimal6, 16
 000                                CONSTANT decimal7, 17
 000                                CONSTANT decimal8, 18
 000                                CONSTANT decimal9, 19
 000                                ;
 000                                ;Binary integer representation of BCD value
 000                                ;
 000                                CONSTANT frequency0, 1A             ;LS byte
 000                                CONSTANT frequency1, 1B
 000                                CONSTANT frequency2, 1C
 000                                CONSTANT frequency3, 1D             ;MS byte
 000                                ;       1E    ; free
 000                                ;       1F    ; free
 000                                ; UART character strings will be stored in scratch pad memory ending in carriage return.
 000                                ; A string can be up to 9 characters with the start location defined by this constant.
 000                                CONSTANT string_start, 20
 000                                CONSTANT string_end, 28
 000                                ;       29-2F  ; free registers
 000                                ; Location 30 to 3F are for registers s0 to sF
 000                                CONSTANT preserve_s0, 30
 000                                CONSTANT preserve_s1, 31
 000                                CONSTANT preserve_s2, 32
 000                                CONSTANT preserve_s3, 33
 000                                CONSTANT preserve_s4, 34
 000                                CONSTANT preserve_s5, 35
 000                                CONSTANT preserve_s6, 36
 000                                CONSTANT preserve_s7, 37
 000                                CONSTANT preserve_s8, 38
 000                                CONSTANT preserve_s9, 39
 000                                CONSTANT preserve_sA, 3A
 000                                CONSTANT preserve_sB, 3B
 000                                CONSTANT preserve_sC, 3C
 000                                CONSTANT preserve_sD, 3D
 000                                CONSTANT preserve_sE, 3E
 000                                CONSTANT preserve_sF, 3F
 000                                ;**************************************************************************************
 000                                ;
 000                                ;ASCII table
 000                                ;
 000                                CONSTANT STX, 02
 000                                CONSTANT ETX, 03
 000                                ;
 000                                CONSTANT ENQ, 05
 000                                CONSTANT ACK, 06
 000                                CONSTANT NAQ, 15
 000                                ;
 000                                ;**************************************************************************************
 000                                ; Limpio Todas las posisiones de memoria, empiezo de 3F y termino en 00
 000                                ; utilizo registros s0, s1
 000                                ;**************************************************************************************
 000  0113F                  reset: LOAD s1, 3F                         ; load address 3F in s1
 001  01000                         LOAD s0, 00                         ; load 0x00 in s0
 002  2E010              clear_spm: STORE s0, (s1)                      ; store s0 value in address pointed by s1
 003  19101                         SUB s1, 01                          ; decrement address in s1
 004  3E002                         JUMP NC, 002[clear_spm]             ; continue until address reach 0x00
 005  01000                         LOAD s0, 00
 006  2D003                         OUTPUT s0, 03[TG]
 007  01000            mode_select: LOAD s0, 00
 008  2D040                         OUTPUT s0, 40[Reset]                ; pongo las salidas y entradas a cero
 009  2F004                         STORE s0, 04[MODO]                  ; guardo en memoria el modo 0
 00A  2F005                         STORE s0, 05[COMANDO]
 00B  01002                         LOAD s0, 02
 00C  2D002                         OUTPUT s0, 02[START]                ; modo stop
 00D                                ;
 00D  2004C                         CALL 04C[disp_Idle]                 ; load next state IDLE
 00E                                ;
 00E                                ;********************** IDLE STATE START *******************************************************
 00E  20166             idle_state: CALL 166[read_Command]              ; read UART
 00F  0B005                         FETCH s0, 05[COMANDO]               ; store command in register s0
 010  1D050                         COMPARE s0, 50["P"]                 ; mode P pulses
 011  3207F                         JUMP Z, 07F[modo_pulsos]            ; go to pulses mode
 012  1D054                         COMPARE s0, 54["T"]                 ; mode T time limit
 013  320AF                         JUMP Z, 0AF[modo_Tiempo]
 014  1D04B                         COMPARE s0, 4B["K"]                 ; mode F free run
 015  320DE                         JUMP Z, 0DE[modo_Libre]
 016  1D04C                         COMPARE s0, 4C["L"]                 ; mode F free run
 017  32100                         JUMP Z, 100[read_data]
 018  1D052                         COMPARE s0, 52["R"]                 ; mode R reboot system
 019  32000                         JUMP Z, 000[reset]
 01A  2006C                         CALL 06C[Send_STATUS]
 01B  2000E                         CALL 00E[idle_state]
 01C                                ;**********************  IDLE STATE END   *****************************************************
 01C                                ;**********************************************************************************************
 01C                                ;JUMP loop
 01C                          loop: ;CALL delay_500ms
 01C  20166                         CALL 166[read_Command]
 01D  0B005                         FETCH s0, 05[COMANDO]               ; pongo el caracter en s0
 01E  1D04C                         COMPARE s0, 4C["L"]                 ; Si presiono la tecla D, es el Enter
 01F  32024                         JUMP Z, 024[curr_reading]
 020  1D058                         COMPARE s0, 58["X"]                 ; Si presiono la tecla D, es el Enter
 021  32028                         JUMP Z, 028[termina]
 022  2006C                         CALL 06C[Send_STATUS]
 023  22025                         JUMP 025[test_end]
 024                                ;
 024  20100           curr_reading: CALL 100[read_data]
 025  0903F               test_end: INPUT s0, 3F[CTRL_status_port]      ; test bit 1 control
 026  0D002                         TEST s0, 02
 027  3A01C                         JUMP C, 01C[loop]
 028                                ;JUMP fin
 028  2003A                termina: CALL 03A[Send_VSTOP]
 029                                ;JUMP test_end;
 029                                ;****************** Codigo enviado al terminar ***************************
 029  20068                    fin: CALL 068[disp_finish]               ; actualizo el estado a f
 02A  20100                         CALL 100[read_data]
 02B  20166               fin_loop: CALL 166[read_Command]              ; leo la UART
 02C  0B005                         FETCH s0, 05[COMANDO]               ; pongo el caracter en s0
 02D  1D04D                         COMPARE s0, 4D["M"]                 ; Si presiono la tecla D, es el Enter
 02E  32007                         JUMP Z, 007[mode_select]            ; es lo mismo que reset
 02F  1D04C                         COMPARE s0, 4C["L"]
 030  32035                         JUMP Z, 035[last_reading]
 031  1D052                         COMPARE s0, 52["R"]                 ; mode R reboot system
 032  32000                         JUMP Z, 000[reset]
 033  2006C                         CALL 06C[Send_STATUS]
 034  2202B                         JUMP 02B[fin_loop]
 035  20100           last_reading: CALL 100[read_data]
 036  2202B                         JUMP 02B[fin_loop]
 037                                ;**************************************************************************************
 037                                ; Mensajes enviados por la UART
 037                                ;  Registros: sF
 037                                ;**************************************************************************************
 037                                ;
 037  01001            Send_VSTART: LOAD s0, 01
 038  2D002                         OUTPUT s0, 02[START]
 039  25000                         RETURN 
 03A                                ;
 03A  01002             Send_VSTOP: LOAD s0, 02
 03B  2D002                         OUTPUT s0, 02[START]
 03C  25000                         RETURN 
 03D                                ;
 03D  01F02               Send_STX: LOAD sF, 02                         ; STX
 03E  20179                         CALL 179[send_to_UART]
 03F  25000                         RETURN 
 040                                ;
 040  01F03               Send_ETX: LOAD sF, 03                         ; ETX
 041  20179                         CALL 179[send_to_UART]
 042  25000                         RETURN 
 043                                ;
 043  01F0D              Send_CRLF: LOAD sF, 0D                         ; CR
 044  20179                         CALL 179[send_to_UART]
 045  01F0A                         LOAD sF, 0A                         ; LF
 046  20179                         CALL 179[send_to_UART]
 047  25000                         RETURN 
 048                                ; ;
 048                                ; Send_ACK:  CALL Send_STX
 048                                ; LOAD sF, 05   ; ACK
 048                                ; CALL send_to_UART
 048                                ; CALL Send_ETX
 048                                ; RETURN
 048                                ; ;
 048                                ; Send_NAK:  CALL Send_STX
 048                                ; LOAD sF, 15   ; NAK
 048                                ; CALL send_to_UART
 048                                ; CALL Send_ETX
 048                                ; RETURN
 048                                ; ;
 048  01F6B            disp_config: LOAD sF, 6B["k"]                    ; 'k'
 049  2FF06                         STORE sF, 06[STATUS]
 04A  2006C                         CALL 06C[Send_STATUS]
 04B  25000                         RETURN 
 04C  01F69              disp_Idle: LOAD sF, 69["i"]                    ; 'i'
 04D  2FF06                         STORE sF, 06[STATUS]
 04E  2006C                         CALL 06C[Send_STATUS]
 04F  25000                         RETURN 
 050  01F65             disp_Error: LOAD sF, 65["e"]                    ; 'i'
 051  2FF06                         STORE sF, 06[STATUS]
 052  2006C                         CALL 06C[Send_STATUS]
 053  25000                         RETURN 
 054  01F70            disp_Pulses: LOAD sF, 70["p"]                    ; 'i'
 055  2FF06                         STORE sF, 06[STATUS]
 056  2006C                         CALL 06C[Send_STATUS]
 057  25000                         RETURN 
 058  01F74              disp_Time: LOAD sF, 74["t"]                    ; 'i'
 059  2FF06                         STORE sF, 06[STATUS]
 05A  2006C                         CALL 06C[Send_STATUS]
 05B  25000                         RETURN 
 05C                                ; disp_Konfig: LOAD sF, "f"   ; 'i'
 05C                                ; STORE sF,STATUS
 05C                                ; CALL Send_STATUS
 05C                                ; RETURN
 05C  01F63             disp_Ready: LOAD sF, 63["c"]                    ; configure status
 05D  2FF06                         STORE sF, 06[STATUS]
 05E  2006C                         CALL 06C[Send_STATUS]
 05F  25000                         RETURN 
 060  01F73             disp_Start: LOAD sF, 73["s"]                    ; waiting start
 061  2FF06                         STORE sF, 06[STATUS]
 062  2006C                         CALL 06C[Send_STATUS]
 063  25000                         RETURN 
 064                                ;
 064  01F77              disp_wait: LOAD sF, 77["w"]
 065  2FF06                         STORE sF, 06[STATUS]                ; 'w'
 066  2006C                         CALL 06C[Send_STATUS]
 067  25000                         RETURN 
 068                                ;
 068  01F66            disp_finish: LOAD sF, 66["f"]
 069  2FF06                         STORE sF, 06[STATUS]                ; 'f'
 06A  2006C                         CALL 06C[Send_STATUS]
 06B  25000                         RETURN 
 06C  2003D            Send_STATUS: CALL 03D[Send_STX]
 06D  0BF06                         FETCH sF, 06[STATUS]
 06E  20179                         CALL 179[send_to_UART]
 06F  20040                         CALL 040[Send_ETX]
 070  25000                         RETURN 
 071                                ;**************************************************************************************
 071  0903F         read_from_CTRL: INPUT s0, 3F[CTRL_status_port]      ;test bit 0 control
 072  0D001                         TEST s0, 01
 073  32071                         JUMP Z, 071[read_from_CTRL]
 074  25000                         RETURN 
 075                                ;control_status_port <= "00000" & control_error & control_busy & salida1_s;
 075  0903F              busy_CTRL: INPUT s0, 3F[CTRL_status_port]      ;test bit 1 control
 076  0D001                         TEST s0, 01
 077  3207C                         JUMP Z, 07C[busy_exit]
 078  0D004                         TEST s0, 04
 079  3A07D                         JUMP C, 07D[busy_error]             ; si el bit de error se enciende se sale
 07A  0D002                         TEST s0, 02
 07B  3E075                         JUMP NC, 075[busy_CTRL]
 07C  25000              busy_exit: RETURN 
 07D  20050             busy_error: CALL 050[disp_Error]
 07E  25000                         RETURN 
 07F                                ;***********************************************************************************************
 07F  20054            modo_pulsos: CALL 054[disp_Pulses]
 080  01001                         LOAD s0, 01
 081  2F004                         STORE s0, 04[MODO]                  ; el modo uno es para conteo por pulsos, no hay punto en el string
 082  20194                         CALL 194[receive_string]            ; string_start y string_end 20 to 28 spm
 083  201CF                         CALL 1CF[ascii_to_bcd]              ; BCD_digit0
 084  20205                         CALL 205[BCD_to_integer]
 085                                ;
 085  0B01A                         FETCH s0, 1A[frequency0]            ; Cargo el valor binario menos significativo
 086  2D004                         OUTPUT s0, 04[Dato0]                ; Lo saco por el puerto en la posicion predefinida
 087  0B01B                         FETCH s0, 1B[frequency1]            ; Cargo el valor binario menos significativo
 088  2D005                         OUTPUT s0, 05[Dato1]                ; Lo saco por el puerto en la posicion predefinida
 089  0B01C                         FETCH s0, 1C[frequency2]            ; Cargo el valor binario menos significativo
 08A  2D006                         OUTPUT s0, 06[Dato2]                ; Lo saco por el puerto en la posicion predefinida
 08B  0B01D                         FETCH s0, 1D[frequency3]            ; Cargo el valor binario menos significativo
 08C  2D007                         OUTPUT s0, 07[Dato3]                ; Lo saco por el puerto en la posicion predefinida
 08D  010FF                         LOAD s0, FF                         ; Modo Pulsos 01
 08E  2D008                         OUTPUT s0, 08[Time0]                ; En la puerta 40, bit 6
 08F  2D009                         OUTPUT s0, 09[Time1]
 090  01000                         LOAD s0, 00
 091  2D040                         OUTPUT s0, 40[Reset]
 092  20060                         CALL 060[disp_Start]
 093  20166             wait_start: CALL 166[read_Command]
 094  0B005                         FETCH s0, 05[COMANDO]               ; pongo el caracter en s0
 095  1D053                         COMPARE s0, 53["S"]                 ; Si recibo S, es el Mando inicio
 096  3209F                         JUMP Z, 09F[continue]
 097  1D050                         COMPARE s0, 50["P"]                 ; Si recibo S, es el Mando inicio
 098  3207F                         JUMP Z, 07F[modo_pulsos]
 099  1D043                         COMPARE s0, 43["C"]                 ; mode R reboot system
 09A  320A4                         JUMP Z, 0A4[confirm]
 09B  1D052                         COMPARE s0, 52["R"]                 ; mode R reboot system
 09C  32000                         JUMP Z, 000[reset]
 09D  2006C                         CALL 06C[Send_STATUS]
 09E  20093                         CALL 093[wait_start]
 09F  20037               continue: CALL 037[Send_VSTART]
 0A0  20071                         CALL 071[read_from_CTRL]
 0A1  20064                         CALL 064[disp_wait]
 0A2  20075                         CALL 075[busy_CTRL]                 ; wait until busy
 0A3  2201C                         JUMP 01C[loop]
 0A4                                ;RETURN
 0A4                                ;
 0A4                       confirm: ; Transmision de los Datos
 0A4  2003D                         CALL 03D[Send_STX]                  ; 0x02
 0A5  01F50                         LOAD sF, 50["P"]                    ; 0x50  Pulsos del Patron
 0A6  20179                         CALL 179[send_to_UART]              ; Envio por UART
 0A7  0B21A                         FETCH s2, 1A[frequency0]
 0A8  0B31B                         FETCH s3, 1B[frequency1]
 0A9  0B41C                         FETCH s4, 1C[frequency2]
 0AA  0B51D                         FETCH s5, 1D[frequency3]
 0AB  201D9                         CALL 1D9[integer_to_BCD]
 0AC  20249                         CALL 249[disp_digits]               ; Envia Cadena con los digitos
 0AD  20040                         CALL 040[Send_ETX]                  ; 0x03
 0AE  22093                         JUMP 093[wait_start]
 0AF                                ;***********************************************************************************************  ;
 0AF                                ;***********************************************************************************************
 0AF  20058            modo_Tiempo: CALL 058[disp_Time]
 0B0  01001                         LOAD s0, 01
 0B1  2F004                         STORE s0, 04[MODO]                  ; Pongo el sistema en modo 2 - Limite de tiempo
 0B2                                ;
 0B2  20194                         CALL 194[receive_string]
 0B3  201CF                         CALL 1CF[ascii_to_bcd]              ;
 0B4  20205                         CALL 205[BCD_to_integer]
 0B5                                ;
 0B5  0B01A                         FETCH s0, 1A[frequency0]            ; Cargo el valor binario menos significativo
 0B6  2D008                         OUTPUT s0, 08[Time0]                ; Lo saco por el puerto en la posicion predefinida
 0B7  0B01B                         FETCH s0, 1B[frequency1]            ; Cargo el valor binario menos significativo
 0B8  2D009                         OUTPUT s0, 09[Time1]                ; Lo saco por el puerto en la posicion predefinida
 0B9                                ; FETCH s0, frequency2  ; Cargo el valor binario menos significativo
 0B9                                ; OUTPUT s0, Dato2   ; Lo saco por el puerto en la posicion predefinida
 0B9                                ; FETCH s0, frequency3  ; Cargo el valor binario menos significativo
 0B9                                ; OUTPUT s0, Dato3   ; Lo saco por el puerto en la posicion predefinida
 0B9  010FF                         LOAD s0, FF
 0BA  2D004                         OUTPUT s0, 04[Dato0]                ; Lo saco por el puerto en la posicion predefinida
 0BB  2D005                         OUTPUT s0, 05[Dato1]                ; Lo saco por el puerto en la posicion predefinida
 0BC  2D006                         OUTPUT s0, 06[Dato2]                ; Lo saco por el puerto en la posicion predefinida
 0BD  2D007                         OUTPUT s0, 07[Dato3]                ; Lo saco por el puerto en la posicion predefinida
 0BE  01000                         LOAD s0, 00
 0BF  2D040                         OUTPUT s0, 40[Reset]
 0C0  20060                         CALL 060[disp_Start]
 0C1  20166           wait_start_t: CALL 166[read_Command]
 0C2  0B005                         FETCH s0, 05[COMANDO]               ; pongo el caracter en s0
 0C3  1D053                         COMPARE s0, 53["S"]                 ; Si recibo S, es el Mando inicio
 0C4  320CD                         JUMP Z, 0CD[continue_t]
 0C5  1D054                         COMPARE s0, 54["T"]                 ; Si recibo S, es el Mando inicio
 0C6  320AF                         JUMP Z, 0AF[modo_Tiempo]
 0C7  1D043                         COMPARE s0, 43["C"]                 ; mode R reboot system
 0C8  320D3                         JUMP Z, 0D3[confirm_t]
 0C9  1D052                         COMPARE s0, 52["R"]                 ; mode R reboot system
 0CA  32000                         JUMP Z, 000[reset]
 0CB  2006C                         CALL 06C[Send_STATUS]
 0CC  200C1                         CALL 0C1[wait_start_t]
 0CD  20037             continue_t: CALL 037[Send_VSTART]
 0CE  20071                         CALL 071[read_from_CTRL]
 0CF  20064                         CALL 064[disp_wait]
 0D0  20075                         CALL 075[busy_CTRL]                 ; wait until busy
 0D1  2201C                         JUMP 01C[loop]
 0D2  25000                         RETURN 
 0D3                                ;
 0D3                     confirm_t: ; Transmision de los Datos
 0D3  2003D                         CALL 03D[Send_STX]                  ; 0x02
 0D4  01F54                         LOAD sF, 54["T"]                    ; 0x50  Pulsos del Patron
 0D5  20179                         CALL 179[send_to_UART]              ; Envio por UART
 0D6  0B21A                         FETCH s2, 1A[frequency0]
 0D7  0B31B                         FETCH s3, 1B[frequency1]
 0D8  0B41C                         FETCH s4, 1C[frequency2]
 0D9  0B51D                         FETCH s5, 1D[frequency3]
 0DA  201D9                         CALL 1D9[integer_to_BCD]
 0DB  20249                         CALL 249[disp_digits]               ; Envia Cadena con los digitos
 0DC  20040                         CALL 040[Send_ETX]                  ; 0x03
 0DD  220C1                         JUMP 0C1[wait_start_t]
 0DE                                ;***********************************************************************************************
 0DE                                ;
 0DE                                ;***********************************************************************************************
 0DE  20048             modo_Libre: CALL 048[disp_config]
 0DF                                ;
 0DF  01003                         LOAD s0, 03
 0E0  2F004                         STORE s0, 04[MODO]                  ; Pongo el sistema en modo 3 - modo libre
 0E1                                ;
 0E1  20194                         CALL 194[receive_string]            ; string_start y string_end 20 to 28 spm
 0E2  201CF                         CALL 1CF[ascii_to_bcd]              ; BCD_digit0
 0E3  20205                         CALL 205[BCD_to_integer]
 0E4                                ;
 0E4  0B01A                         FETCH s0, 1A[frequency0]            ; Cargo el valor binario menos significativo
 0E5  2D003                         OUTPUT s0, 03[TG]                   ; Lo saco por el puerto en la posicion predefinida
 0E6                                ;
 0E6  01000                         LOAD s0, 00
 0E7  2D040                         OUTPUT s0, 40[Reset]
 0E8                                ;
 0E8                                ;
 0E8  2005C                         CALL 05C[disp_Ready]
 0E9  20166           wait_start_f: CALL 166[read_Command]
 0EA  0B005                         FETCH s0, 05[COMANDO]               ; pongo el caracter en s0
 0EB  1D04D                         COMPARE s0, 4D["M"]                 ; Si presiono la tecla D, es el Enter
 0EC  32007                         JUMP Z, 007[mode_select]            ; es lo mismo que reset
 0ED  1D04B                         COMPARE s0, 4B["K"]                 ; Si presiono la tecla D, es el Enter
 0EE  320DE                         JUMP Z, 0DE[modo_Libre]             ; es lo mismo que reset
 0EF  1D043                         COMPARE s0, 43["C"]                 ; mode R reboot system
 0F0  320F5                         JUMP Z, 0F5[confirm_f]
 0F1  1D052                         COMPARE s0, 52["R"]                 ; mode R reboot system
 0F2  32000                         JUMP Z, 000[reset]
 0F3  2006C                         CALL 06C[Send_STATUS]
 0F4  200E9                         CALL 0E9[wait_start_f]
 0F5                                ; continue_f:  CALL Send_VSTART
 0F5                                ; CALL read_from_CTRL
 0F5                                ; CALL disp_wait
 0F5                                ; CALL busy_CTRL  ; wait until busy
 0F5                                ; JUMP loop
 0F5                                ; RETURN
 0F5                                ;
 0F5                     confirm_f: ; Transmision de los Datos
 0F5  2003D                         CALL 03D[Send_STX]                  ; 0x02
 0F6  01F4B                         LOAD sF, 4B["K"]                    ; 0x50  Pulsos del Patron
 0F7  20179                         CALL 179[send_to_UART]              ; Envio por UART
 0F8  0B21A                         FETCH s2, 1A[frequency0]
 0F9  01300                         LOAD s3, 00                         ;frequency1
 0FA  01400                         LOAD s4, 00                         ;frequency2
 0FB  01500                         LOAD s5, 00                         ;frequency3
 0FC  201D9                         CALL 1D9[integer_to_BCD]
 0FD  20249                         CALL 249[disp_digits]               ; Envia Cadena con los digitos
 0FE  20040                         CALL 040[Send_ETX]                  ; 0x03
 0FF  220E9                         JUMP 0E9[wait_start_f]
 100                                ;********************************************************************************************************+
 100                     read_data: 
 100                                ; Lectura de los pulsos del Patron
 100  09200                         INPUT s2, 00[A_count0_port]         ; Leo el contador A, Pulsos Patron
 101  09301                         INPUT s3, 01[A_count1_port]
 102  09402                         INPUT s4, 02[A_count2_port]
 103  09503                         INPUT s5, 03[A_count3_port]
 104  201D9                         CALL 1D9[integer_to_BCD]            ; Esta funcion convierte los datos de los registros s2,s3,s4,s5
 105                                ; Transmision de los Datos
 105  2003D                         CALL 03D[Send_STX]                  ; 0x02
 106  01F50                         LOAD sF, 50["P"]                    ; 0x50  Pulsos del Patron
 107  20179                         CALL 179[send_to_UART]              ; Envio por UART
 108  20249                         CALL 249[disp_digits]               ; Envia Cadena con los digitos
 109  20040                         CALL 040[Send_ETX]                  ; 0x03
 10A                                ;----------------------------
 10A                                ;
 10A                                ;CALL delay_20ms
 10A                                ; Lectura de los pulsos del Patron
 10A  09204                         INPUT s2, 04[B_count0_port]         ; Leo el contador B, Pulsos bajo prueba
 10B  09305                         INPUT s3, 05[B_count1_port]
 10C  09406                         INPUT s4, 06[B_count2_port]
 10D  09507                         INPUT s5, 07[B_count3_port]
 10E  201D9                         CALL 1D9[integer_to_BCD]            ; Esta funcion convierte los datos de los registros s2,s3,s4,s5
 10F                                ; Transmision de los Datos
 10F  2003D                         CALL 03D[Send_STX]                  ; 0x02
 110  01F70                         LOAD sF, 70["p"]                    ; 0x70  Pulsos del IBC
 111  20179                         CALL 179[send_to_UART]              ; Envio por UART
 112  20249                         CALL 249[disp_digits]               ; Envia Cadena con los digitos
 113  20040                         CALL 040[Send_ETX]                  ; 0x03
 114                                ;
 114  09220                         INPUT s2, 20[A_period0_port]        ; Leo el periodo A, Pulsos Patron
 115  09321                         INPUT s3, 21[A_period1_port]
 116  09422                         INPUT s4, 22[A_period2_port]
 117  09523                         INPUT s5, 23[A_period3_port]
 118  201D9                         CALL 1D9[integer_to_BCD]            ; Esta funcion convierte los datos de los registros s2,s3,s4,s5
 119                                ; Transmision de los Datos
 119  2003D                         CALL 03D[Send_STX]                  ; 0x02
 11A  01F44                         LOAD sF, 44["D"]                    ; 0x50  Pulsos del Patron
 11B  20179                         CALL 179[send_to_UART]              ; Envio por UART
 11C  20249                         CALL 249[disp_digits]               ; Envia Cadena con los digitos
 11D  20040                         CALL 040[Send_ETX]                  ; 0x03
 11E                                ;
 11E  09224                         INPUT s2, 24[B_period0_port]        ; Leo el periodo B, Pulsos IBC
 11F  09325                         INPUT s3, 25[B_period1_port]
 120  09426                         INPUT s4, 26[B_period2_port]
 121  09527                         INPUT s5, 27[B_period3_port]
 122  201D9                         CALL 1D9[integer_to_BCD]            ; Esta funcion convierte los datos de los registros s2,s3,s4,s5
 123                                ; Transmision de los Datos
 123  2003D                         CALL 03D[Send_STX]                  ; 0x02
 124  01F64                         LOAD sF, 64["d"]                    ; 0x50  Pulsos del Patron
 125  20179                         CALL 179[send_to_UART]              ; Envio por UART
 126  20249                         CALL 249[disp_digits]               ; Envia Cadena con los digitos
 127  20040                         CALL 040[Send_ETX]                  ; 0x03
 128                                ;
 128                                ;CALL delay_20ms
 128                                ; Lectura de Tiempo del Patron
 128  0920C                         INPUT s2, 0C[Timer1_E_0_port]       ; Leo la parte entera del timer 1
 129  0930D                         INPUT s3, 0D[Timer1_E_1_port]
 12A  0940E                         INPUT s4, 0E[Timer1_E_2_port]
 12B  0950F                         INPUT s5, 0F[Timer1_E_3_port]
 12C  201D9                         CALL 1D9[integer_to_BCD]            ; Esta funcion convierte los datos de los registros s2,s3,s4,s5
 12D                                ; Transmision de los Datos
 12D  2003D                         CALL 03D[Send_STX]                  ; 0x02
 12E  01F54                         LOAD sF, 54["T"]
 12F  20179                         CALL 179[send_to_UART]
 130  20249                         CALL 249[disp_digits]               ; muestra los digitos convertidos
 131  01F2E                         LOAD sF, 2E["."]                    ; escribo un punto
 132  20179                         CALL 179[send_to_UART]
 133  09208                         INPUT s2, 08[Timer1_F_0_port]       ; Leo la parte fraccionaria del timer 2
 134  09309                         INPUT s3, 09[Timer1_F_1_port]
 135  0940A                         INPUT s4, 0A[Timer1_F_2_port]
 136  0950B                         INPUT s5, 0B[Timer1_F_3_port]
 137  201D9                         CALL 1D9[integer_to_BCD]            ; Esta funcion convierte los datos de los registros s2,s3,s4,s5
 138  20239                         CALL 239[disp_digits_timer]         ; muestra los digitos convertidos
 139  20040                         CALL 040[Send_ETX]                  ; 0x03
 13A                                ;
 13A                                ;CALL delay_20ms
 13A                                ; Lectura de Tiempo bajo prueba
 13A  0921C                         INPUT s2, 1C[Timer2_E_0_port]       ; Leo la parte entera del timer 2
 13B  0931D                         INPUT s3, 1D[Timer2_E_1_port]
 13C  0941E                         INPUT s4, 1E[Timer2_E_2_port]
 13D  0951F                         INPUT s5, 1F[Timer2_E_3_port]
 13E  201D9                         CALL 1D9[integer_to_BCD]            ; Esta funcion convierte los datos de los registros s2,s3,s4,s5
 13F                                ; Transmision de los Datos
 13F  2003D                         CALL 03D[Send_STX]                  ; 0x02
 140  01F74                         LOAD sF, 74["t"]
 141  20179                         CALL 179[send_to_UART]
 142  20249                         CALL 249[disp_digits]               ; muestra los digitos convertidos
 143  01F2E                         LOAD sF, 2E["."]                    ; escribo un punto
 144  20179                         CALL 179[send_to_UART]
 145  09218                         INPUT s2, 18[Timer2_F_0_port]       ; Leo la parte fraccionaria del timer 2
 146  09319                         INPUT s3, 19[Timer2_F_1_port]
 147  0941A                         INPUT s4, 1A[Timer2_F_2_port]
 148  0951B                         INPUT s5, 1B[Timer2_F_3_port]
 149  201D9                         CALL 1D9[integer_to_BCD]            ; Esta funcion convierte los datos de los registros s2,s3,s4,s5
 14A  20239                         CALL 239[disp_digits_timer]         ; muestra los digitos convertidos
 14B  20040                         CALL 040[Send_ETX]                  ; 0x03
 14C                                ;CALL delay_20ms
 14C  2006C                         CALL 06C[Send_STATUS]
 14D  20043                         CALL 043[Send_CRLF]
 14E  25000                         RETURN 
 14F                                ; Software Delays
 14F                                ; ---------------
 14F                                ;
 14F                                INCLUDE "C:\FPGA\Contador_Cmod_S6_Fredyfrec\PSM\soft_delays_100mhz.psm"["soft_delays_100mhz.psm"]
 14F                                ;
 14F                                ;------------------------------------------------------------------------------------------
 14F                                ; Copyright © 2012-2013, Xilinx, Inc.
 14F                                ; This file contains confidential and proprietary information of Xilinx, Inc. and is
 14F                                ; protected under U.S. and international copyright and other intellectual property laws.
 14F                                ;------------------------------------------------------------------------------------------
 14F                                ;
 14F                                ; Disclaimer:
 14F                                ; This disclaimer is not a license and does not grant any rights to the materials
 14F                                ; distributed herewith. Except as otherwise provided in a valid license issued to
 14F                                ; you by Xilinx, and to the maximum extent permitted by applicable law: (1) THESE
 14F                                ; MATERIALS ARE MADE AVAILABLE "AS IS" AND WITH ALL FAULTS, AND XILINX HEREBY
 14F                                ; DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY,
 14F                                ; INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT,
 14F                                ; OR FITNESS FOR ANY PARTICULAR PURPOSE; and (2) Xilinx shall not be liable
 14F                                ; (whether in contract or tort, including negligence, or under any other theory
 14F                                ; of liability) for any loss or damage of any kind or nature related to, arising
 14F                                ; under or in connection with these materials, including for any direct, or any
 14F                                ; indirect, special, incidental, or consequential loss or damage (including loss
 14F                                ; of data, profits, goodwill, or any type of loss or damage suffered as a result
 14F                                ; of any action brought by a third party) even if such damage or loss was
 14F                                ; reasonably foreseeable or Xilinx had been advised of the possibility of the same.
 14F                                ;
 14F                                ; CRITICAL APPLICATIONS
 14F                                ; Xilinx products are not designed or intended to be fail-safe, or for use in any
 14F                                ; application requiring fail-safe performance, such as life-support or safety
 14F                                ; devices or systems, Class III medical devices, nuclear facilities, applications
 14F                                ; related to the deployment of airbags, or any other applications that could lead
 14F                                ; to death, personal injury, or severe property or environmental damage
 14F                                ; (individually and collectively, "Critical Applications"). Customer assumes the
 14F                                ; sole risk and liability of any use of Xilinx products in Critical Applications,
 14F                                ; subject only to applicable laws and regulations governing limitations on product
 14F                                ; liability.
 14F                                ;
 14F                                ; THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS PART OF THIS FILE AT ALL TIMES.
 14F                                ;
 14F                                ;------------------------------------------------------------------------------------------
 14F                                ;
 14F                                ;             _  ______ ____  ____  __  __  __
 14F                                ;            | |/ / ___|  _ \/ ___||  \/  |/ /_
 14F                                ;            | ' / |   | |_) \___ \| |\/| | '_ \
 14F                                ;            | . \ |___|  __/ ___) | |  | | (_) )
 14F                                ;            |_|\_\____|_|   |____/|_|  |_|\___/
 14F                                ;
 14F                                ;
 14F                                ;                PicoBlaze Reference Design.
 14F                                ;
 14F                                ;
 14F                                ; Ken Chapman - Xilinx Ltd
 14F                                ;
 14F                                ; 6th September 2012 - Initial version
 14F                                ;    18th March 2013 - Addition of 20ms delay
 14F                                ;
 14F                                ; This file contains routines that implement delays in software. It should be recognised
 14F                                ; that the delay periods are the result of executing instructions, and because every
 14F                                ; instruction takes 2 clock cycles to execute, it is possible to determine the exact
 14F                                ; delay period. However, besides the obvious dependency on the clock frequency, it
 14F                                ; should also be recognised that any interrupts to KCPSM6 (or use of sleep mode) will
 14F                                ; impact the timing. In general, it is better only to use soft delay routines in
 14F                                ; situations where approximate timing is adequate; in those situations KCPSM6 will often
 14F                                ; exceed your requirements.
 14F                                ;
 14F                                ;
 14F                                ;------------------------------------------------------------------------------------------
 14F                                ; Software Delays based on 100MHz clock
 14F                                ;------------------------------------------------------------------------------------------
 14F                                ;
 14F                                ; The number of iterations of a delay loop required to form each delay required are
 14F                                ; loaded into the register set [s2,s1,s0] and then the delay loop is started.
 14F                                ;
 14F                                ; Registers used s0, s1, s2
 14F                                ;
 14F                                ; 1ms is 10,000 x 100ns     (10,000 = 002710 hex)
 14F                                ;
 14F  01200              delay_1ms: LOAD s2, 00
 150  01127                         LOAD s1, 27
 151  01010                         LOAD s0, 10
 152  2215F                         JUMP 15F[software_delay]
 153                                ;
 153                                ; 20ms is 200,000 x 100ns     (200,000 = 030D40 hex)
 153                                ;
 153  01203             delay_20ms: LOAD s2, 03
 154  0110D                         LOAD s1, 0D
 155  01040                         LOAD s0, 40
 156  2215F                         JUMP 15F[software_delay]
 157                                ;
 157                                ;
 157                                ; 1s is 5,000,000 x 100ns     (5,000,000 =  4C4B40 hex)
 157  0124C            delay_500ms: LOAD s2, 4C
 158  0114B                         LOAD s1, 4B
 159  01040                         LOAD s0, 40
 15A  2215F                         JUMP 15F[software_delay]
 15B                                ; 1s is 10,000,000 x 100ns     (10,000,000 = 989680 hex)
 15B                                ;
 15B  01298               delay_1s: LOAD s2, 98
 15C  01196                         LOAD s1, 96
 15D  01080                         LOAD s0, 80
 15E  2215F                         JUMP 15F[software_delay]
 15F                                ;
 15F                                ; The delay loop decrements [s2,s1,s0] until it reaches zero
 15F                                ; Each decrement cycle is 5 instructions which is 10 clock cycles (100ns at 100MHz)
 15F                                ;
 15F  00000         software_delay: LOAD s0, s0                         ;pad loop to make it 10 clock cycles (5 instructions)
 160  19001                         SUB s0, 01[1'd]
 161  1B100                         SUBCY s1, 00[0'd]
 162  1B200                         SUBCY s2, 00[0'd]
 163  3615F                         JUMP NZ, 15F[software_delay]
 164  25000                         RETURN 
 165                                ;
 165                                ;
 165                                ;------------------------------------------------------------------------------------------
 165                                ; End of 'soft_delays_100mhz.psm'
 165                                ;------------------------------------------------------------------------------------------
 165                                ;
 165                                INCLUDE "C:\FPGA\Contador_Cmod_S6_Fredyfrec\PSM\functions.psm"["functions.psm"]
 165                  prompt_input: ;CALL send_prompt                         ;Prompt 'KCPSM3>'
 165  20194                         CALL 194[receive_string]
 166  20173           read_Command: CALL 173[read_from_UART]            ; Lee el caracter 1 de la uart
 167  1DF02                         COMPARE sF, 02                      ; Verifico que sea un STX
 168  3616F                         JUMP NZ, 16F[bad_command]
 169  20173                         CALL 173[read_from_UART]            ; Lee el caracter 2 de la uart
 16A  2FF05                         STORE sF, 05[COMANDO]               ; lo guardo en la memoria
 16B  20173                         CALL 173[read_from_UART]            ; Lee el caracter de la uart
 16C  1DF03                         COMPARE sF, 03                      ; Verifico que tengo un STX
 16D  3616F                         JUMP NZ, 16F[bad_command]
 16E  25000                         RETURN 
 16F  010FF            bad_command: LOAD s0, FF
 170  2F005                         STORE s0, 05[COMANDO]
 171  201AE                         CALL 1AE[clear_UART_Rx_loop]
 172  25000                         RETURN 
 173                                ;**************************************************************************************
 173                                ;*** Lee un caracter por la UART
 173                                ;*** usa los registros s0 y sF
 173                                ;**************************************************************************************
 173                                ;
 173  09040         read_from_UART: INPUT s0, 40[UART_status_port]      ; test Rx_FIFO buffer
 174  0D010                         TEST s0, 10[rx_data_present]
 175  36177                         JUMP NZ, 177[read_character]
 176  22173                         JUMP 173[read_from_UART]
 177  09F80         read_character: INPUT sF, 80[UART_read_port]        ; read from FIFO
 178  25000                         RETURN 
 179                                ;
 179                                ;**************************************************************************************
 179                                ;*** Transmite un caracter por la UART
 179                                ;*** usa los registros s0 y sF
 179                                ;**************************************************************************************
 179                                ;
 179  09040           send_to_UART: INPUT s0, 40[UART_status_port]      ; verifico si hay especio en buffer
 17A  0D002                         TEST s0, 02[tx_full]
 17B  3217D                         JUMP Z, 17D[UART_write]             ; si hay espacio transmito
 17C  22179                         JUMP 179[send_to_UART]              ; si no hay espacio espero
 17D  2DF80             UART_write: OUTPUT sF, 80[UART_write_port]
 17E  25000                         RETURN 
 17F                                ;
 17F                                ;**************************************************************************************
 17F                                ;*** Transmite Cadena envia loa valores almacenados en las 9 posisiones de memoria
 17F                                ;*** usa los registros sE y sF
 17F                                ;**************************************************************************************
 17F                                ;transmit_string: LOAD sE, string_start       ; Carga en sE, el valor 0x20, posición del MSD
 17F                                ; next_char_tx:  FETCH sF, (sE)                 ; cargo el sF, la posicion de memoria apuntada por sE
 17F                                ; CALL send_to_UART              ; envio el valor de sF por la UART
 17F                                ; COMPARE sE, string_end         ; comparo con el final de la cadena = 0x28
 17F                                ; RETURN Z
 17F                                ; ADD sE, 01
 17F                                ; JUMP next_char_tx
 17F                                ;**************************************************************************************
 17F                                ;
 17F                                ;**************************************************************************************
 17F                                ;*** Transmite Cadena envia loa valores almacenados en las 9 posisiones de memoria
 17F                                ;*** usa los registros sE y sF (sD modo de operacion)
 17F                                ;**************************************************************************************
 17F  0BD04        transmit_string: FETCH sD, 04[MODO]
 180  01E20                         LOAD sE, 20[string_start]           ; Carga en sE, el valor 0x20, posición del MSD
 181  0AFE0           next_char_tx: FETCH sF, (sE)                      ; cargo el sF, la posicion de memoria apuntada por sE
 182  20179                         CALL 179[send_to_UART]              ; envio el valor de sF por la UART
 183  1DE28                         COMPARE sE, 28[string_end]          ; comparo con el final de la cadena = 0x28
 184  31000                         RETURN Z
 185  11E01                         ADD sE, 01
 186  1DE23                         COMPARE sE, 23                      ; pone el punto en el caracter 23
 187  36181                         JUMP NZ, 181[next_char_tx]
 188  1DD02                         COMPARE sD, 02
 189  36181                         JUMP NZ, 181[next_char_tx]          ; si estoy en el modo 2 pongo el punto
 18A  01F2E                         LOAD sF, 2E["."]
 18B  20179                         CALL 179[send_to_UART]
 18C  22181                         JUMP 181[next_char_tx]
 18D                                ;**************************************************************************************
 18D                                ;
 18D                                ;**************************************************************************************
 18D                                ;*** Transmite Cadena envia loa valores almacenados en las 9 posisiones de memoria
 18D                                ;*** usa los registros sE y sF
 18D                                ;**************************************************************************************
 18D               transmit_spaces: ;LOAD s5, 44             ; Linea 4 posision 5
 18D                                ;CALL LCD_cursor
 18D  01E00                         LOAD sE, 00                         ; Carga en sE, el valor 0x20, posición del MSD
 18E  01F20             next_space: LOAD sF, 20[" "]                    ; cargo el sF, la posicion de memoria apuntada por sE
 18F  20179                         CALL 179[send_to_UART]              ; envio el valor de sF por la UART
 190  1DE20                         COMPARE sE, 20                      ; comparo con el final de la cadena = 0x28
 191  31000                         RETURN Z
 192  11E01                         ADD sE, 01
 193  2218E                         JUMP 18E[next_space]
 194                                ;**************************************************************************************
 194                                ;**************************************************************************************
 194                                ;***  Función para leer datos desde el teclado y genera string de datos  ***
 194                                ;***  Utiliza las constantes string_start y string_end      ***
 194                                ;***  Registros usados s0, sF             ***
 194                                ;**************************************************************************************
 194                receive_string: ;
 194             receive_full_test: ;
 194  09040                         INPUT s0, 40[UART_status_port]      ; verifico si Buffer UART esta lleno
 195  0D008                         TEST s0, 08[rx_full]
 196  361AE                         JUMP NZ, 1AE[clear_UART_Rx_loop]
 197  20173                         CALL 173[read_from_UART]            ; Lee el caracter de la uart
 198                                ;
 198  1DF03                         COMPARE sF, 03                      ; Si presiono la tecla ETX, es el Enter
 199  321A6                         JUMP Z, 1A6[check_zeros]
 19A  1DF02                         COMPARE sF, 02                      ; Verifico que tengo un STX
 19B  321A4                         JUMP Z, 1A4[clear_all]
 19C                                ;****** Verifico que solo sean caracteres entre 0 y 9 ********************
 19C  000F0                         LOAD s0, sF
 19D  110C6                         ADD s0, C6                          ; reject character codes above '9' (39 hex)
 19E  3A194                         JUMP C, 194[receive_full_test]      ; carry flag is set
 19F  190F6                         SUB s0, F6                          ; reject character codes below '0' (30 hex)
 1A0  3A194                         JUMP C, 194[receive_full_test]      ; si no hay acarreo el dato esta entre 0 y 9
 1A1                                ;***************************************************************************
 1A1  201B3                         CALL 1B3[move_left]
 1A2  2FF28                         STORE sF, 28[string_end]            ; Guardo siempre en la ultima posicion
 1A3  22194                         JUMP 194[receive_full_test]         ; despues regreso a solicitar otro dato
 1A4                                ;
 1A4                                ;
 1A4  201C8              clear_all: CALL 1C8[Fill_zeros]
 1A5  22194                         JUMP 194[receive_full_test]
 1A6  01028            check_zeros: LOAD s0, 28[string_end]
 1A7  0A100             check_loop: FETCH s1, (s0)
 1A8  1D130                         COMPARE s1, 30["0"]
 1A9  35000                         RETURN NZ
 1AA  1D020                         COMPARE s0, 20[string_start]
 1AB  32194                         JUMP Z, 194[receive_full_test]
 1AC  19001                         SUB s0, 01
 1AD  221A7                         JUMP 1A7[check_loop]
 1AE  09040     clear_UART_Rx_loop: INPUT s0, 40[UART_status_port]      ;test Rx_FIFO buffer for data
 1AF  0D010                         TEST s0, 10[rx_data_present]
 1B0  31000                         RETURN Z                            ;finish when buffer is empty
 1B1  09F80                         INPUT sF, 80[UART_read_port]        ;read from FIFO and ignore
 1B2  221AE                         JUMP 1AE[clear_UART_Rx_loop]
 1B3                                ;
 1B3                                ;**************************************************************************************
 1B3                                ;**************************************************************************************
 1B3                                ;***  Función para mover string a la izquierda        ***
 1B3                                ;***  Utiliza las constantes string_start y string_end      ***
 1B3                                ;***  Registros usados s0, s1 y s2           ***
 1B3                                ;**************************************************************************************
 1B3                                ;
 1B3  01020              move_left: LOAD s0, 20[string_start]
 1B4  00100                ml_loop: LOAD s1, s0
 1B5  11101                         ADD s1, 01
 1B6  0A210                         FETCH s2, (s1)
 1B7  2E200                         STORE s2, (s0)
 1B8  1D128                         COMPARE s1, 28[string_end]
 1B9  31000                         RETURN Z
 1BA  11001                         ADD s0, 01
 1BB  221B4                         JUMP 1B4[ml_loop]
 1BC                                ;
 1BC                                ;**************************************************************************************
 1BC                                ;**************************************************************************************
 1BC                                ;***  Función para mover string a la izquierda        ***
 1BC                                ;***  Utiliza las constantes string_start y string_end      ***
 1BC                                ;***  Registros usados s0, s1 y s2           ***
 1BC                                ;**************************************************************************************
 1BC                                ;
 1BC  01028             move_right: LOAD s0, 28[string_end]
 1BD  00100                mr_loop: LOAD s1, s0
 1BE  19101                         SUB s1, 01
 1BF  0A210                         FETCH s2, (s1)
 1C0  2E200                         STORE s2, (s0)
 1C1  19001                         SUB s0, 01
 1C2  1D120                         COMPARE s1, 20[string_start]
 1C3  321C5                         JUMP Z, 1C5[move_zero]
 1C4  221BD                         JUMP 1BD[mr_loop]
 1C5  01230              move_zero: LOAD s2, 30["0"]
 1C6  2E200                         STORE s2, (s0)
 1C7  25000                         RETURN 
 1C8                                ;
 1C8                                ;**************************************************************************************
 1C8                                ;**************************************************************************************
 1C8                                ;***  Función para llenar string de datos          ***
 1C8                                ;***  Utiliza las constantes string_start y string_end      ***
 1C8                                ;***  Registros usados s0 y s1            ***
 1C8                                ;**************************************************************************************
 1C8                                ;
 1C8  01030             Fill_zeros: LOAD s0, 30["0"]
 1C9  01120                Fill_s0: LOAD s1, 20[string_start]           ; Usa el valor de s0
 1CA  2E010                   Fill: STORE s0, (s1)
 1CB  1D128                         COMPARE s1, 28[string_end]
 1CC  31000                         RETURN Z
 1CD  11101                         ADD s1, 01
 1CE  221CA                         JUMP 1CA[Fill]
 1CF                                ;
 1CF                                ;**************************************************************************************
 1CF                                ;**************************************************************************************
 1CF                                ;***  Función para convertir string de ASCII a BCD       ***
 1CF                                ;***  Constantes Usadas: string_start, string_end y BCD_digit0    ***
 1CF                                ;***  Registros Usados:  s0, s1 y s2           ***
 1CF                                ;**************************************************************************************
 1CF                                ;
 1CF  01028           ascii_to_bcd: LOAD s0, 28[string_end]             ; string_end
 1D0  01107                         LOAD s1, 07[BCD_digit0]             ; BCD_digit0
 1D1  0A200             ascii_loop: FETCH s2, (s0)                      ; Leo de la Memoria
 1D2  0320F                         AND s2, 0F                          ; Obtengo el nibble Bajo
 1D3  2E210                         STORE s2, (s1)                      ; Escribo en la Memoria
 1D4  1D020                         COMPARE s0, 20[string_start]        ; Comparo con el Ultimo Caracter
 1D5  31000                         RETURN Z                            ; Regreso si es Cero
 1D6  19001                         SUB s0, 01                          ; Redusco el puntero de String
 1D7  11101                         ADD s1, 01                          ; Aumento el puntero de BCD
 1D8  221D1                         JUMP 1D1[ascii_loop]                ;
 1D9                                ;
 1D9                                ;**************************************************************************************
 1D9                                ;**************************************************************************************
 1D9                                ;***  Funcion para convertir entero de 32-bit a BCD       ***
 1D9                                ;***  Constantes Usadas: decimal0            ***
 1D9                                ;***  Registros Usados: s0,s2,s3,s4,s5,s6,s7,s8,s9,sA,sB,sC,sD,sE,sF   ***
 1D9                                ;***  Registros de Entrada: [s5,s4,s3,s2]         ***
 1D9                                ;***       MSByte     LSByte        ***
 1D9                                ;**************************************************************************************
 1D9                                ;
 1D9  01E0A         integer_to_BCD: LOAD sE, 0A                         ;10 digits to be formed from value up to 4294967295
 1DA  01F10                         LOAD sF, 10[decimal0]               ;pointer for LS-Digit
 1DB  201E1        int_to_BCD_loop: CALL 1E1[divide_32bit_by_10]
 1DC  2E1F0                         STORE s1, (sF)                      ;remainder becomes digit value
 1DD  11F01                         ADD sF, 01                          ;move to next most significant digit
 1DE  19E01                         SUB sE, 01                          ;one less digit to compute
 1DF  361DB                         JUMP NZ, 1DB[int_to_BCD_loop]
 1E0  25000                         RETURN 
 1E1                                ;
 1E1                                ;Divide 32-bit binary integer by 10
 1E1                                ;
 1E1                                ;The value to be divided is held in register set [s5,s4,s3,s2]
 1E1                                ;and this is where the result is returned to.
 1E1                                ;
 1E1                                ;At then end of the integer division the remainder in the range 0 to 9
 1E1                                ;will be in register s1.
 1E1                                ;
 1E1                                ;Registers used s0, s2,s3,s4,s5,s6,s7,s8,s9,sA,sB,sC,sD
 1E1                                ;
 1E1  00A20     divide_32bit_by_10: LOAD sA, s2                         ;copy input value to set [sD,sC,sB,sA]
 1E2  00B30                         LOAD sB, s3
 1E3  00C40                         LOAD sC, s4
 1E4  00D50                         LOAD sD, s5
 1E5  01200                         LOAD s2, 00                         ;clear result
 1E6  01300                         LOAD s3, 00
 1E7  01400                         LOAD s4, 00
 1E8  01500                         LOAD s5, 00
 1E9  019A0                         LOAD s9, A0                         ;initialise '10' value into msb's of set [s9,s8,s7,s6]
 1EA  01800                         LOAD s8, 00
 1EB  01700                         LOAD s7, 00
 1EC  01600                         LOAD s6, 00
 1ED  0101D                         LOAD s0, 1D                         ;29 subtract and shift iterations to be performed
 1EE  18A60             div10_loop: SUB sA, s6                          ;perform 32-bit subtract [sD,sC,sB,sA]-[s9,s8,s7,s6]
 1EF  1AB70                         SUBCY sB, s7
 1F0  1AC80                         SUBCY sC, s8
 1F1  1AD90                         SUBCY sD, s9
 1F2  3A1F5                         JUMP C, 1F5[div10_restore]
 1F3  14207                         SL1 s2                              ;shift '1' into result
 1F4  221FA                         JUMP 1FA[div10_shifts]
 1F5  10A60          div10_restore: ADD sA, s6                          ;perform 32-bit addition [sD,sC,sB,sA]+[s9,s8,s7,s6]
 1F6  12B70                         ADDCY sB, s7
 1F7  12C80                         ADDCY sC, s8
 1F8  12D90                         ADDCY sD, s9
 1F9  14206                         SL0 s2                              ;shift '0' into result
 1FA  14300           div10_shifts: SLA s3                              ;complete 32-bit shift left
 1FB  14400                         SLA s4
 1FC  14500                         SLA s5
 1FD  1490E                         SR0 s9                              ;divide '10' value by 2 (shift right 1 place)
 1FE  14808                         SRA s8
 1FF  14708                         SRA s7
 200  14608                         SRA s6
 201  19001                         SUB s0, 01                          ;count iterations
 202  361EE                         JUMP NZ, 1EE[div10_loop]
 203  001A0                         LOAD s1, sA                         ;remainder of division
 204  25000                         RETURN 
 205                                ;**************************************************************************************
 205                                ;
 205                                ;
 205                                ;
 205                                ;**************************************************************************************
 205                                ; Convert 9 digit BCD frequency into 32-bit binary integer
 205                                ;**************************************************************************************
 205                                ;
 205                                ; Both values are stored in scratch pad memory
 205                                ;    BCD values in ascending locations BCD_digit0 to BCD_digit8
 205                                ;    Binary frequency in ascending locations frequency0 to frequency3
 205                                ;
 205                                ;Each digit is read in turn and its value is determined by repeated
 205                                ;decrement until reaching zero. Each decrement causes a value to be added
 205                                ;to the memory locations forming the frequency value as binary integer.
 205                                ;The process requires approximately 1600 instructions to convert the highest
 205                                ;value 999,999,999 which is approximately 64us at 50MHz clock rate.
 205                                ;
 205                                ;Registers used s0,s1,s2,s3,s4,s5,s6,s7,s8,s9,sA,sB
 205                                ;
 205  01209         BCD_to_integer: LOAD s2, 09                         ;9 digits to convert
 206  01000                         LOAD s0, 00                         ;clear frequency value ready to accumulate result
 207  2F01A                         STORE s0, 1A[frequency0]
 208  2F01B                         STORE s0, 1B[frequency1]
 209  2F01C                         STORE s0, 1C[frequency2]
 20A  2F01D                         STORE s0, 1D[frequency3]
 20B  01B00                         LOAD sB, 00                         ;initialise BCD digit weighting [sB,sA,s9,s8] to 1
 20C  01A00                         LOAD sA, 00
 20D  01900                         LOAD s9, 00
 20E  01801                         LOAD s8, 01
 20F  01307                         LOAD s3, 07[BCD_digit0]             ;locate LS-digit
 210  0A130  next_BCD_to_int_digit: FETCH s1, (s3)
 211  1D100      BCD_digit_convert: COMPARE s1, 00                      ;test for zero
 212  32221                         JUMP Z, 221[next_digit_value]
 213  0B01A                         FETCH s0, 1A[frequency0]            ;add 32-bit digit weighting to memory value
 214  10080                         ADD s0, s8
 215  2F01A                         STORE s0, 1A[frequency0]
 216  0B01B                         FETCH s0, 1B[frequency1]
 217  12090                         ADDCY s0, s9
 218  2F01B                         STORE s0, 1B[frequency1]
 219  0B01C                         FETCH s0, 1C[frequency2]
 21A  120A0                         ADDCY s0, sA
 21B  2F01C                         STORE s0, 1C[frequency2]
 21C  0B01D                         FETCH s0, 1D[frequency3]
 21D  120B0                         ADDCY s0, sB
 21E  2F01D                         STORE s0, 1D[frequency3]
 21F  19101                         SUB s1, 01                          ;decrement digit value
 220  22211                         JUMP 211[BCD_digit_convert]
 221                                ;Increase weighting by 10x
 221  007B0       next_digit_value: LOAD s7, sB                         ;copy existing weighting
 222  006A0                         LOAD s6, sA
 223  00590                         LOAD s5, s9
 224  00480                         LOAD s4, s8
 225  14806                         SL0 s8                              ;multiply weight by 4x (shift left 2 places)
 226  14900                         SLA s9
 227  14A00                         SLA sA
 228  14B00                         SLA sB
 229  14806                         SL0 s8
 22A  14900                         SLA s9
 22B  14A00                         SLA sA
 22C  14B00                         SLA sB
 22D  10840                         ADD s8, s4                          ;add previous weight to form 5x multiplication
 22E  12950                         ADDCY s9, s5
 22F  12A60                         ADDCY sA, s6
 230  12B70                         ADDCY sB, s7
 231  14806                         SL0 s8                              ;multiply weight by 2x (shift left 1 places)
 232  14900                         SLA s9
 233  14A00                         SLA sA
 234  14B00                         SLA sB                              ;weight value is now 10x previous value
 235  11301                         ADD s3, 01                          ;move to next digit for conversion
 236  19201                         SUB s2, 01
 237  36210                         JUMP NZ, 210[next_BCD_to_int_digit]
 238  25000                         RETURN 
 239                                ;
 239                                ;**************************************************************************************
 239                                ;***  Función para convertir enviar digitos decimales por la UART    ***
 239                                ;***  Constantes Usadas: decimal9 a decimal0         ***
 239                                ;***  Registros Usados:  sE, UART(s0 y sF)         ***
 239                                ;**************************************************************************************
 239                                ;
 239  0BF17      disp_digits_timer: FETCH sF, 17[decimal7]              ; 100mS
 23A  20246                         CALL 246[disp_digit_timer]
 23B  0BF16                         FETCH sF, 16[decimal6]              ; 10mS
 23C  20246                         CALL 246[disp_digit_timer]
 23D  0BF15                         FETCH sF, 15[decimal5]              ; 1mS
 23E  20246                         CALL 246[disp_digit_timer]
 23F  0BF14                         FETCH sF, 14[decimal4]              ; 100us
 240  20246                         CALL 246[disp_digit_timer]
 241  0BF13                         FETCH sF, 13[decimal3]              ; 10uS
 242  20246                         CALL 246[disp_digit_timer]
 243  0BF12                         FETCH sF, 12[decimal2]              ; 1us
 244  20246                         CALL 246[disp_digit_timer]
 245                                ;FETCH sF, decimal1            ; 100nS
 245                                ;CALL disp_digit_timer
 245                                ;FETCH sF, decimal0      ; 10nS
 245                                ;CALL disp_digit_timer
 245  25000                         RETURN 
 246                                ;
 246  11F30       disp_digit_timer: ADD sF, 30["0"]                     ;convierto el numero a ASCII
 247  20179                         CALL 179[send_to_UART]
 248  25000                         RETURN 
 249                                ;
 249                                ;**************************************************************************************
 249                                ;***  Función para convertir y enviar digitos por la UART      ***
 249                                ;***  Constantes Usadas: decimal9 a decimal0         ***
 249                                ;***  Registros Usados:  sE, UART(s0 y sF)         ***
 249                                ;**************************************************************************************
 249                                ;
 249  01EFF            disp_digits: LOAD sE, FF                         ;bandera de caracter nulo
 24A  0BF19                         FETCH sF, 19[decimal9]              ;
 24B  20269                         CALL 269[zero_test]
 24C  2026D                         CALL 26D[disp_digit]
 24D  0BF18                         FETCH sF, 18[decimal8]              ;
 24E  20269                         CALL 269[zero_test]
 24F  2026D                         CALL 26D[disp_digit]
 250  0BF17                         FETCH sF, 17[decimal7]              ;
 251  20269                         CALL 269[zero_test]
 252  2026D                         CALL 26D[disp_digit]
 253  0BF16                         FETCH sF, 16[decimal6]              ;
 254  20269                         CALL 269[zero_test]
 255  2026D                         CALL 26D[disp_digit]
 256  0BF15                         FETCH sF, 15[decimal5]              ;
 257  20269                         CALL 269[zero_test]
 258  2026D                         CALL 26D[disp_digit]
 259  0BF14                         FETCH sF, 14[decimal4]              ;
 25A  20269                         CALL 269[zero_test]
 25B  2026D                         CALL 26D[disp_digit]
 25C  0BF13                         FETCH sF, 13[decimal3]              ;
 25D  20269                         CALL 269[zero_test]
 25E  2026D                         CALL 26D[disp_digit]
 25F  0BF12                         FETCH sF, 12[decimal2]              ;
 260  20269                         CALL 269[zero_test]
 261  2026D                         CALL 26D[disp_digit]
 262  0BF11                         FETCH sF, 11[decimal1]              ;
 263  20269                         CALL 269[zero_test]
 264  2026D                         CALL 26D[disp_digit]
 265  0BF10                         FETCH sF, 10[decimal0]              ;
 266  11F30                         ADD sF, 30["0"]                     ;
 267  20179                         CALL 179[send_to_UART]
 268  25000                         RETURN 
 269                                ;
 269  1DF00              zero_test: COMPARE sF, 00                      ; compara para ver si es cero
 26A  31000                         RETURN Z
 26B  01E00                         LOAD sE, 00                         ; si es cero cambio la bandera
 26C  25000                         RETURN 
 26D                                ;
 26D  1DEFF             disp_digit: COMPARE sE, FF
 26E  32272                         JUMP Z, 272[blank_digit]
 26F  11F30                         ADD sF, 30["0"]                     ;
 270  20179                         CALL 179[send_to_UART]
 271  25000                         RETURN 
 272                   blank_digit: ;LOAD sF, "0"    ; imprimo los zeros
 272                                ;CALL send_to_UART
 272  25000                         RETURN 
 273                                ;**************************************************************************************
 273                                ;
 273                                ;
 273                                ;
 273                                ;**************************************************************************************
 273                                ;
 273                                ;**************************************************************************************
 273                                ;Interrupt Service Routine
 273                                ;**************************************************************************************
 273                                ;
 273                                ;**************************************************************************************
 273                                ;Interrupt Vector
 273                                ;**************************************************************************************
 273                                ;
 273                                ; ADDRESS 3FF
 273                                ; JUMP ISR


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

C:\FPGA\Contador_Cmod_S6_Fredyfrec\PSM\ROM.psm
C:\FPGA\Contador_Cmod_S6_Fredyfrec\PSM\soft_delays_100mhz.psm
C:\FPGA\Contador_Cmod_S6_Fredyfrec\PSM\functions.psm



List of defined constants

 CONSTANT name     Value        Source PSM File

 timestamp_hours   14'd         
 timestamp_minutes 30'd         
 timestamp_seconds 33'd         
 datestamp_year    18'd         
 datestamp_month   10'd         
 datestamp_day     14'd         
 NUL               00           
 BEL               07           
 BS                08           
 HT                09           
 LF                0A           
 VT                0B           
 CR                0D           
 ESC               1B           
 DEL               7F           
 DCS               90           
 ST                9C           
 A_count0_port     00           ROM.psm
 A_count1_port     01           ROM.psm
 A_count2_port     02           ROM.psm
 A_count3_port     03           ROM.psm
 B_count0_port     04           ROM.psm
 B_count1_port     05           ROM.psm
 B_count2_port     06           ROM.psm
 B_count3_port     07           ROM.psm
 Timer1_F_0_port   08           ROM.psm
 Timer1_F_1_port   09           ROM.psm
 Timer1_F_2_port   0A           ROM.psm
 Timer1_F_3_port   0B           ROM.psm
 Timer1_E_0_port   0C           ROM.psm
 Timer1_E_1_port   0D           ROM.psm
 Timer1_E_2_port   0E           ROM.psm
 Timer1_E_3_port   0F           ROM.psm
 Timer2_F_0_port   18           ROM.psm
 Timer2_F_1_port   19           ROM.psm
 Timer2_F_2_port   1A           ROM.psm
 Timer2_F_3_port   1B           ROM.psm
 Timer2_E_0_port   1C           ROM.psm
 Timer2_E_1_port   1D           ROM.psm
 Timer2_E_2_port   1E           ROM.psm
 Timer2_E_3_port   1F           ROM.psm
 A_period0_port    20           ROM.psm
 A_period1_port    21           ROM.psm
 A_period2_port    22           ROM.psm
 A_period3_port    23           ROM.psm
 B_period0_port    24           ROM.psm
 B_period1_port    25           ROM.psm
 B_period2_port    26           ROM.psm
 B_period3_port    27           ROM.psm
 CTRL_status_port  3F           ROM.psm
 UART_status_port  40           ROM.psm
 tx_half_full      01           ROM.psm
 tx_full           02           ROM.psm
 rx_half_full      04           ROM.psm
 rx_full           08           ROM.psm
 rx_data_present   10           ROM.psm
 UART_read_port    80           ROM.psm
 UART_write_port   80           ROM.psm
 Reset             40           ROM.psm
 START             02           ROM.psm
 TG                03           ROM.psm
 Dato0             04           ROM.psm
 Dato1             05           ROM.psm
 Dato2             06           ROM.psm
 Dato3             07           ROM.psm
 Time0             08           ROM.psm
 Time1             09           ROM.psm
 count0            00           ROM.psm
 count1            01           ROM.psm
 count2            02           ROM.psm
 count3            03           ROM.psm
 MODO              04           ROM.psm
 COMANDO           05           ROM.psm
 STATUS            06           ROM.psm
 BCD_digit0        07           ROM.psm
 BCD_digit1        08           ROM.psm
 BCD_digit2        09           ROM.psm
 BCD_digit3        0A           ROM.psm
 BCD_digit4        0B           ROM.psm
 BCD_digit5        0C           ROM.psm
 BCD_digit6        0D           ROM.psm
 BCD_digit7        0E           ROM.psm
 BCD_digit8        0F           ROM.psm
 decimal0          10           ROM.psm
 decimal1          11           ROM.psm
 decimal2          12           ROM.psm
 decimal3          13           ROM.psm
 decimal4          14           ROM.psm
 decimal5          15           ROM.psm
 decimal6          16           ROM.psm
 decimal7          17           ROM.psm
 decimal8          18           ROM.psm
 decimal9          19           ROM.psm
 frequency0        1A           ROM.psm
 frequency1        1B           ROM.psm
 frequency2        1C           ROM.psm
 frequency3        1D           ROM.psm
 string_start      20           ROM.psm
 string_end        28           ROM.psm
 preserve_s0       30           ROM.psm
 preserve_s1       31           ROM.psm
 preserve_s2       32           ROM.psm
 preserve_s3       33           ROM.psm
 preserve_s4       34           ROM.psm
 preserve_s5       35           ROM.psm
 preserve_s6       36           ROM.psm
 preserve_s7       37           ROM.psm
 preserve_s8       38           ROM.psm
 preserve_s9       39           ROM.psm
 preserve_sA       3A           ROM.psm
 preserve_sB       3B           ROM.psm
 preserve_sC       3C           ROM.psm
 preserve_sD       3D           ROM.psm
 preserve_sE       3E           ROM.psm
 preserve_sF       3F           ROM.psm
 STX               02           ROM.psm
 ETX               03           ROM.psm
 ENQ               05           ROM.psm
 ACK               06           ROM.psm
 NAQ               15           ROM.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.70"        
 datestamp$        "14 Oct 2018"  
 timestamp$        "14:30:33"     



List of line labels

   Label                   Addr  Source PSM File

   reset                   000   ROM.psm
   clear_spm               002   ROM.psm
   mode_select             007   ROM.psm
   idle_state              00E   ROM.psm
   loop                    01C   ROM.psm
   curr_reading            024   ROM.psm
   test_end                025   ROM.psm
   termina                 028   ROM.psm
 * fin                     029   ROM.psm
   fin_loop                02B   ROM.psm
   last_reading            035   ROM.psm
   Send_VSTART             037   ROM.psm
   Send_VSTOP              03A   ROM.psm
   Send_STX                03D   ROM.psm
   Send_ETX                040   ROM.psm
   Send_CRLF               043   ROM.psm
   disp_config             048   ROM.psm
   disp_Idle               04C   ROM.psm
   disp_Error              050   ROM.psm
   disp_Pulses             054   ROM.psm
   disp_Time               058   ROM.psm
   disp_Ready              05C   ROM.psm
   disp_Start              060   ROM.psm
   disp_wait               064   ROM.psm
   disp_finish             068   ROM.psm
   Send_STATUS             06C   ROM.psm
   read_from_CTRL          071   ROM.psm
   busy_CTRL               075   ROM.psm
   busy_exit               07C   ROM.psm
   busy_error              07D   ROM.psm
   modo_pulsos             07F   ROM.psm
   wait_start              093   ROM.psm
   continue                09F   ROM.psm
   confirm                 0A4   ROM.psm
   modo_Tiempo             0AF   ROM.psm
   wait_start_t            0C1   ROM.psm
   continue_t              0CD   ROM.psm
   confirm_t               0D3   ROM.psm
   modo_Libre              0DE   ROM.psm
   wait_start_f            0E9   ROM.psm
   confirm_f               0F5   ROM.psm
   read_data               100   ROM.psm
 * delay_1ms               14F   soft_delays_100mhz.psm
 * delay_20ms              153   soft_delays_100mhz.psm
 * delay_500ms             157   soft_delays_100mhz.psm
 * delay_1s                15B   soft_delays_100mhz.psm
   software_delay          15F   soft_delays_100mhz.psm
 * prompt_input            165   functions.psm
   read_Command            166   functions.psm
   bad_command             16F   functions.psm
   read_from_UART          173   functions.psm
   read_character          177   functions.psm
   send_to_UART            179   functions.psm
   UART_write              17D   functions.psm
 * transmit_string         17F   functions.psm
   next_char_tx            181   functions.psm
 * transmit_spaces         18D   functions.psm
   next_space              18E   functions.psm
   receive_string          194   functions.psm
   receive_full_test       194   functions.psm
   clear_all               1A4   functions.psm
   check_zeros             1A6   functions.psm
   check_loop              1A7   functions.psm
   clear_UART_Rx_loop      1AE   functions.psm
   move_left               1B3   functions.psm
   ml_loop                 1B4   functions.psm
 * move_right              1BC   functions.psm
   mr_loop                 1BD   functions.psm
   move_zero               1C5   functions.psm
   Fill_zeros              1C8   functions.psm
 * Fill_s0                 1C9   functions.psm
   Fill                    1CA   functions.psm
   ascii_to_bcd            1CF   functions.psm
   ascii_loop              1D1   functions.psm
   integer_to_BCD          1D9   functions.psm
   int_to_BCD_loop         1DB   functions.psm
   divide_32bit_by_10      1E1   functions.psm
   div10_loop              1EE   functions.psm
   div10_restore           1F5   functions.psm
   div10_shifts            1FA   functions.psm
   BCD_to_integer          205   functions.psm
   next_BCD_to_int_digit   210   functions.psm
   BCD_digit_convert       211   functions.psm
   next_digit_value        221   functions.psm
   disp_digits_timer       239   functions.psm
   disp_digit_timer        246   functions.psm
   disp_digits             249   functions.psm
   zero_test               269   functions.psm
   disp_digit              26D   functions.psm
   blank_digit             272   functions.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD            100
 STAR              -

 AND               1
 OR                -
 XOR               -

 ADD              15
 ADDCY             9
 SUB              12
 SUBCY             5

 TEST              9
 TESTCY            -
 COMPARE          39
 COMPARECY         -

 SL0               4
 SL1               1
 SLX               -
 SLA              12
 RL                -
 SR0               1
 SR1               -
 SRX               -
 SRA               3
 RR                -

 REGBANK           -

 INPUT            41
 OUTPUT           22
 OUTPUTK           -

 STORE            50
 FETCH            50

 DISABLE           -
 ENABLE            -
 RETURNI           -

 JUMP             74
 JUMP@             -
 CALL            154
 CALL@             -
 RETURN           43
 LOAD&RETURN       -

 HWBUILD           -



End of KCPSM6 log file.
